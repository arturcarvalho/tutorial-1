# Hammer Tutorial

Welcome to Hammer! If you haven't yet, check out the [Hammer README](https://github.com/hammerframework/hammer/blob/master/README.md) to get a little background on why we created Hammer and the problems it's meant to solve. Hammer brings several existing technologies together for the first time into what we think is the future of single page applications.

In this tutorial we're going to build a blog engine. In reality a blog is probably not the ideal candidate for a Hammer app: blog articles can be stored in a CMS and statically generated to HTML files and served as flat files from a CDN. But as most developers are familiar with a blog and it uses all of the features we want to demonstrate, we decided to build one anyway.

## Prerequisites

This tutorial assumes you are already familiar with a few core concepts:

- [React](https://reactjs.org/)
- [GraphQL](https://graphql.org/)
- [The JAMstack](https://jamstack.org/)

You could work through this tutorial without knowing anything about these technologies but you may find yourself getting lost in terminology that we don't stop and take the time to explain. It also helps knowing where the line is between what is built into React and what additional features Hammer brings to the table.

## Installation & Starting Development

We have a set of command line tools that aids in creating various parts of your Hammer app. Install with either `node` or `yarn` (the rest of this guide assumes Yarn):

    yarn global add @hammerframework/hammer-cli

Note that we install `hammer-cli` globally so that we can create apps from scratch rather than creating a directory and adding it to just that project. Now you can use the Hammer command line tools everywhere. Let's use it right now to create the basic structure of our app:

    hammer new hammerblog

After some commands fly by you'll have a new directory `hammerblog` containing several directories and files. Change to that directory and let's start the development server:

    cd hammerblog
    hammer dev

Your browser should open to http://localhost:8910 show the Hammer welcome page:

[screenshot]

We've already initialized a git repo for you so you may want to save the current state of the app as your first commit.

    git add .
    git commit -am 'First commit'

## Hammer File Structure

Let's take a look at the files and directories that were created for us (config files have been excluded for now):

<img src="https://user-images.githubusercontent.com/300/70482979-05a2d800-1a9c-11ea-9a38-b3ead0f3b5f1.png" alt="hammerblog directory structure" style="width: 300px">

At the top level we have two directories, `api` and `web`. Hammer separates the backend (`api`) and frontend (`web`) concerns into their own paths in the codebase. Yarn refers to these as "workspaces". When you add packages going forward you'll need to specify which workspace they should go in. For example (don't run these commands, we're just looking at the syntax):

    yarn workspace web add marked
    yarn workspace api add better-fs

Within `api` there are two directories:

- `prisma` contains the plumbing for the database:
  - `schema.prisma` contains the database schema
  - `migrations` will contain files that track the structure of our database changing over time
  - `seeds.js` is used to populate your database with any data that needs to exist for your app to run at all (maybe an admin user or site configuration).

  If your app doesn't need access to a SQL-like database then you can delete the `prisma` directory completely and even remove the `prisma2` package.
- `src` contains all other backend code. `api/src` contains three more directories:
  - `functions` will contain any lambda functions your app needs in addition to the `graphql.js` file auto-generated by Hammer. This file is required to use the GraphQL API. If you don't need GraphQL you can remove this function completely (and remove the `apollo` package).
  - `graphql` contains SDL files which define your GraphQL schema and types.
  - `services` contains business logic related to your data. When you're querying or mutating data for GraphQL, that code ends up here, but in a format that's resuable in other places in your application.

That's it for the backend. Let's take a look at the frontend `web` directory:

- `components` contain your traditional React components as well as Hammer *Cells*.
- `layouts` contain HTML/components that wrap your content and are shared across pages.
- `pages` contain components and are optionally wrapped inside layouts and are the "landing page" for a given URL (a URL like `/articles/hello-world` will map to one page and `/contact-us` will map to another). There are two pages included in a new app:
  - `NotFoundPage.js` will be served when no other route is found (see `Routes.js` below).
  - `FatalErrorPage.js` will be rendered when there is an uncaught error that can't be recovered from and would otherwise cause our application to really blow up (normally rendering a blank page).
- `index.html` is the standard React starting point for our app.
- `index.js` contains the bootstraping code to get our Hammer app up and running.
- `Routes.js` contains the route definitions for our app which map a URL to a *Page*

## Our First Page

Let's give our users something to look at besides the Hammer welcome page. We'll use the `hammer` command line tool to create a page for us:

    hammer page home /

This will do two things:

- create `/web/src/pages/HomePage/HomePage.js`
- add a `<Route>` in `/web/Routes.js` that maps the path `/` to the new _HomePage_ page

> If you look in Routes you'll notice that we're referencing a component, `HomePage`, that isn't imported anywhere. Hammer automatically imports all pages in the Routes file since we're going to need to reference them all anyway. It saves a potentially huge `import` declaration from cluttering up our routes file.

In fact this page is already live. If you reload your browser you should see this new page instead of the Hammer welcome page:

![image](https://user-images.githubusercontent.com/300/70487560-9b456400-1aaa-11ea-8dd1-d74fa4123154.png)

It's not pretty, but it's a start! Open the page in your editor, change some text and save. Your browser should reload with your new text. Open up `/web/src/Routes.js` and take a look at the route that was created:

    <Route path="/" page={HomePage}>

Try changing the route to something like:

    <Route path="/hello" page={HomePage}>

When the browser reloads you should see the Hammer welcome page again. That's because we abandoned the root URL so Hammer takes over and shows the splash screen again. Change your URL to `http://localhost:8910/hello" and you should see our page again.

Change the route back to `/` before continuing!

## A Second Page and a Link

Let's create an "About" page for our blog so everyone knows about the geniuses behind this achievement. We'll create another page using `hammer`:

    hammer generate page about /about

http://localhost:8910/about should show our new page. But no one's going to find it by changing the URL so let's add a link from our homepage to the About page and vice versa. We'll start creating a simple header and nav bar at the same time:

```javascript
// web/src/pages/HomePage/HomePage.js

import { Link, routes } from 'src/lib/HammerRouter'

const HomePage = () => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      Home
    </main>
  )
}

export default HomePage
```

Let's point out a few things here:

- Hammer loves [Function Components](https://www.robinwieruch.de/react-function-component). We'll make extensive use of [React Hooks](https://reactjs.org/docs/hooks-intro.html) as we go and these are only enabled in function components. You're free to create class components if you want but we haven't found any cases that functional components plus hooks have been unable to handle.
- Hammer's `<Link>` tag, in its most basic usage, takes a single `to` attribute. That `to` attribute will point to a _Named Route_. The function you call is the `name` attribute on the `<Route>`:

    `<Route path="/about" page={AboutPage} name="about" />`

  You can change the name to whatever you like but Hammer generates them as the name of the page, minus the "Page" suffix, and staring with a lowercase letter. `AboutPage` becomes `about()`. Named routes are awesome because if you ever change your route, you only change it `Router.js` and every link using named routes will automatically point to the correct place.

Once we get to the About page we don't have any way to get back so lets add a link there as well:

```javascript
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from 'src/lib/HammerRouter'

const AboutPage = () => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.aboutPage()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      <p>
        This site was created to demonstrate my mastery of Hammer:
        Look on my works, ye mighty, and despair!
      </p>
      <Link to={routes.homePage()}>Return home</Link>
    </main>
  )
}

export default AboutPage
```

Great! Try that out in the browser and verify you can get back and forth.

As a world-class developer you probably saw that copy and pasted `<header>` and developed an involuntary facial tick. We feel you. That's why Hammer has a little something called _Layouts_.

## Layouts

One way to solve the `<header>` dilemma would be to create a `<Header>` component and include it in both `HomePage` and `AboutPage`. That works, but is there a better solution? Ideally there should only be one reference to the `<header>` anywhere in our code.

When you look at these two pages what do they really care about? They have some content they want to display. They really shouldn't have to care what comes "before" (a `<header>`) or "after" (a `<footer>`). That's exactly what layouts do: they wrap your pages in a component that then renders the page as its child:

<img src="https://user-images.githubusercontent.com/300/70486228-dc874500-1aa5-11ea-81d2-eab69eb96ec0.png" alt="Layouts structure diagram" style="width: 300px">

Let's create a component to hold that `<header>`:

    hammer generate layout blog

That created `/web/src/layouts/BlogLayout/BlogLayout.js`. We're calling this the "blog" layout because we may have other layouts at some point in the future (an "admin" layout, perhaps?).

Copy the `<header>` from both `HomePage` and `AboutPage` and add it to the layout instead. Let's take out the duplicated `<main>` tag as well:

```javascript
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from 'src/lib/HammerRouter'

const BlogLayout = (props) => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.aboutPage()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      { props.children }
    </main>
  )
}

export default BlogLayout
```

`props.children` is where the magic will happen. Any page content given to the layout will be rendered here. Back to `HomePage` and `AboutPage`, we add a `<BlogLayout>` wrapper and now they're back to containing only the content they care about:

```javascript
// web/src/pages/HomePage/HomePage.js
import { Link, routes } from "src/lib/HammerRouter";
import BlogLayout from "src/layouts/BlogLayout";

const HomePage = () => {
  return <BlogLayout>Home</BlogLayout>;
};

export default HomePage;

// web/src/pages/AboutPage/AboutPage.js
import { Link, routes } from "src/lib/HammerRouter";
import BlogLayout from "src/layouts/BlogLayout";

const AboutPage = () => {
  return (
    <BlogLayout>
      <p>
        This site was created to demonstrate my mastery of Hammer:
        Look on my works, ye mighty, and despair!
      </p>
      <Link to={routes.homePage()}>Return home</Link>
    </BlogLayout>
  );
};

export default AboutPage;
```

Back to the browser and you should see...nothing different. But that's good, it means our layout is working.

> ### Why are things named the way they are?
>
> You may have noticed some duplication in Hammer's file names. Pages live in a directory called `/pages` and also contain `Page` in their name. Same with Layouts. What's the deal?
>
> When you have dozens of files open in your editor it's easy to get lost, especially when you have several files with names that are similar or even the same (they happen to be in different directories). We've found that the extra duplication in the names of files is worth the productivity benefit when scanning through your open tabs.
>
> If you're using the [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) plugin this also helps disambiguate when browsing through your component stack:
>
> <img src="https://user-images.githubusercontent.com/300/70564528-3854db00-1b45-11ea-9976-d6e5ddfb571f.png" style="width:400px">

## Getting Dynamic

These two pages are great and all but where are the actual blog posts in this blog? Let's work on those next.

For the purposes of our tutorial we're going to get our blog posts from a database. Hammer is unique in that we know that SQL will be around for a long time to come, and any app of significant complexity will need to talk to one sooner or later. Because of that we've made SQL access a first-class citizen and that starts with the schema.

### Creating the Database Schema

We need to decide what data we'll need for a blog post. We'll expand on this at some point, but at a minimum we'll want to start with:

* `id` the unique identifier for this blog post (all of our database tables will have one of these)
* `title`
* `body` the actual content of the blog post

We use [Prisma Photon](https://photonjs.prisma.io/) to talk to the database. Prisma has another library called Lift which lets us update the database's schema in a predictable way and snapshot each of those changes. Each change is called a *migration* and Lift will create one when we make changes to our schema.

First let's define the data structre for a post in the database. Open up `/api/prisma/schema.prisma` and add the following:

```javascript
model Post {
  id    Int @id
  title String
  body  String
}
```

### Migrations

That was simple. Now we'll want to snapshot this has a migration:

    hammer db:save

When it asks what you want to name this migration its for your own benefit—neither Hammer nor Photon care about the migration's name. Something like "create posts" is perfect. After the command completes you'll see a new subdirectory under `/api/prisma/migrations` that has a timestamp of now and the name you gave the migration. It will contain a couple files inside (a snapshot of what the schema looked like at that point in time in `schema.prisma` and the directives that Lift will use make the change to the database in `steps.json`).

We apply the migration with another command:

    hammer db:up

Since this is the first time this command has been run you'll be asked if you want to create the database (yes, you do). It will create a SQLite file at `/api/prisma/dev.db` and then apply the migration, creating a new table called `Post` with the fields we defined above.

### Scaffolding a Post Editor

We haven't decided on the look and feel of our site yet, but wouldn't it be amazing if we could play around with posts without having to build a bunch of pages that we'll probably throw away once the design team gets back to us? Lucky for us, "Amazing" is Hammer's middle name! It has no last name.

Let's generate a *scaffold* that will allow us to perform all the CRUD actions on posts so we can not only verify that we've got the right fields in the database, but let us get some sample posts in there so we can laying our our pages and see real content. Hammer has a generator for just the occasion:

    hammer generate scaffold post

Let's point the browser to `http://localhost:8910/posts` and see what we have:

[screenshot]

Well that's barely more than we got when we generated a page. What happens if we click that "New Post" button?

[screenshot]

Okay, now we're getting somewhere. Fill in the title and body and click "Submit".

[screenshot]

Did we just create a post in the database? And then show that post here on this page? Yes, yes we did. Try creating another:

[screenshot]

But what if we click "Edit" on one of those posts?

[Screenshot]

Okay but what if we click "Delete"?

[screenshot]

So, Hammer just created a complete scaffold for our posts table to allow us to perform all CRUD actions through these simple pages. No need to open a GUI or login through a terminal window and write SQL froms scratch. Pretty neat, right?

Here's what happened when we ran that `hammer generate scaffold post` command:

* Added an `sdl` file to define several GraphQL endpoints in `/api/src/graphql/posts.sdl.js`
* Added a *services* file in `/api/src/services/posts.js` which makes the Photon calls to get data in and out of the database
* Created several pages in `/web/src/pages`:
  * `PostsPage`
  * `CreatePostPage`
  * `EditPostPage`
  * `ShowPostPage`
* Created routes for those pages in `/web/src/Routes.js`

Since we scaffolded "post" we got the pluralized name for our newly generated SDL, service and pages (they do contain deal with multiple posts, not just one post!)

### Creating a Homepage

We can start replacing these pages one by one as get styles, or maybe move them to the admin section of our site and build our own display pages from scratch. The public facing site won't let viewers create, edit or delete posts. What *can* they do?

1. View a list of posts (without links to edit/delete)
2. View a single post

Since we'll probably want a way to create and edit posts going forward let's keep the scaffolded pages as they are and create new ones for these two items.

We already have `HomePage` so we won't need to create that. We want to display a list of posts to the user so we'll need to add that logic. We need to get the content from the database and we don't want the user to just see a blank screen in the meantime (depending on network conditions, server location, etc), so we'll want to show some kind of loading message or animation. And if there's an error retrieving the data we should handle that as well. And what about when we open source this blog engine and someone puts it live without any content in the database? It'd be nice if there was some kind of blank slate message.

Oh boy, our first page and we already have to worry about loading states ,errors and blank slates...or do we?

### Cells

These features are common in most web apps. We wanted to see if there was something we could do to make developers' lives easier when it comes to adding them to a typical component. We think we've come up with something to help and we call them *Cells*.

When you create a cell you export several specially named constants and then we take it from there. A typical cell may look something like:

```javascript
import Post from 'src/components/Blog/Post'

export const Query = gql`
  query {
    posts {
      id
      title
      body
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>No posts yet!</div>

export const Failure = ({ message }) => <div>Error loading posts: {message}</div>

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <Post key={post.id} post={post} summary={true} />
  ))
}
```

When React renders this component Hammer will:

* Perform the `Query` and display the `Loader` component until a response is received
* Once the query returns it will display one of three states:
  * If the data return is empty (null or empty array), the `Empty` component
  * If there was an error, the `Failure` component
  * Otherwise, the `Success` component

There are also some lifecycle helpers like `beforeQuery` (for massaging any props before being given to the `Query`) and `afterQuery` (for massaging the data returned from GraphQL but before being displayed in the `Success` component)

The minimum you need for a cell is the `Query` and `Success` exports. You can handle your own empty or failure states inside the `Success` component itself with some conditionals, but we think those just bog down your component display with messy display logic that can be extracted away.

A guideline for when to use cells is if your component needs some data from the database or other service that may be delayed in responding.
