# Hammer Tutorial

Welcome to Hammer! If you haven't yet, check out the [Hammer README](https://github.com/hammerframework/hammer/blob/master/README.md) to get a little background on why we created Hammer and the problems it's meant to solve. Hammer brings several existing technologies together for the first time into what we think is the future of single page applications.

In this tutorial we're going to build a blog engine. In reality a blog is probably not the ideal candidate for a Hammer app: blog articles can be stored in a CMS and statically generated to HTML files and served as flat files from a CDN. But as most developers are familiar with a blog and it uses all of the features we want to demonstrate, we decided to build one anyway.

## Prerequisites

This tutorial assumes you are already familiar with a few core concepts:

- [React](https://reactjs.org/)
- [GraphQL](https://graphql.org/)
- [The JAMstack](https://jamstack.org/)

You could work through this tutorial without knowing anything about these technologies but you may find yourself getting lost in terminology that we don't stop and take the time to explain. It also helps knowing where the line is between what is built into React and what additional features Hammer brings to the table.

## Installation & Starting Development

We have a set of command line tools that aids in creating various parts of your Hammer app. Install with either `node` or `yarn` (the rest of this guide assumes Yarn):

    yarn global add @hammerframework/hammer-cli

Note that we install `hammer-cli` globally so that we can create apps from scratch rather than creating a directory and adding it to just that project. Now you can use the Hammer command line tools everywhere. Let's use it right now to create the basic structure of our app:

    hammer new hammerblog

After some commands fly by you'll have a new directory `hammerblog` containing several directories and files. Change to that directory and let's start the development server:

    cd hammerblog
    hammer dev

Your browser should open to http://localhost:8910 and show the Hammer welcome page:

[screenshot]

We've already initialized a git repo for you so you may want to save the current state of the app as your first commit.

    git add .
    git commit -am 'First commit'

## Hammer File Structure

Let's take a look at the files and directories that were created for us (config files have been excluded for now):

<img src="https://user-images.githubusercontent.com/300/70482979-05a2d800-1a9c-11ea-9a38-b3ead0f3b5f1.png" alt="hammerblog directory structure" style="width: 300px">

At the top level we have two directories, `api` and `web`. Hammer separates the backend (`api`) and frontend (`web`) concerns into their own paths in the codebase. Yarn refers to these as "workspaces". When you add packages going forward you'll need to specify which workspace they should go in. For example (don't run these commands, we're just looking at the syntax):

    yarn workspace web add marked
    yarn workspace api add better-fs

Within `api` there are two directories:

- `prisma` contains the plumbing for the database:
  - `schema.prisma` contains the database schema
  - `migrations` will contain files that track the structure of our database changing over time
  - `seeds.js` is used to populate your database with any data that needs to exist for your app to run at all (maybe an admin user or site configuration).

  If your app doesn't need access to a SQL-like database then you can delete the `prisma` directory completely and even remove the `prisma2` package.
- `src` contains all other backend code. `api/src` contains three more directories:
  - `functions` will contain any lambda functions your app needs in addition to the `graphql.js` file auto-generated by Hammer. This file is required to use the GraphQL API. If you don't need GraphQL you can remove this function completely (and remove the `apollo` package).
  - `graphql` contains your GraphQL schema (SDL) and resolvers.
  - `services` contains business logic related to your data. When you're querying or mutating data for GraphQL, that code ends up here, but in a format that's resuable in other places in your application.

That's it for the backend. Let's take a look at the frontend `web` directory:

- `components` contain your traditional React components as well as Hammer _Cells_.
- `layouts` contain HTML/components that wrap your content and are shared across pages.
- `pages` contain components and are optionally wrapped inside layouts and are the "landing page" for a given URL (a URL like `/articles/hello-world` will map to one page and `/contact-us` will map to another). There are two pages included in a new app:
  - `NotFoundPage.js` will be served when no other route is found (see `Routes.js` below).
  - `FatalErrorPage.js` will be rendered when there is an uncaught error that can't be recovered from and would otherwise cause our application to really blow up (normally rendering a blank page).
- `index.html` is the standard React starting point for our app.
- `index.js` contains the bootstraping code to get our Hammer app up and running.
- `Routes.js` contains the route definitions for our app which map a URL to a _Page_

## Our First Page

Let's give our users something to look at besides the Hammer welcome page. We'll use the `hammer` command line tool to create a page for us:

    hammer generate page home /

This does two things:

- Creates `/web/src/pages/HomePage/HomePage.js`. Hammer takes the name you specified as the first argument, capitalizes it, and appends "Page" to construct your new page component.
- Adds a `<Route>` in `/web/src/Routes.js` that maps the path `/` to the new _HomePage_ page.

> If you look in Routes you'll notice that we're referencing a component, `HomePage`, that isn't imported anywhere. Hammer automatically imports all pages in the Routes file since we're going to need to reference them all anyway. It saves a potentially huge `import` declaration from cluttering up our routes file.

In fact this page is already live. If you reload your browser you should see this new page instead of the Hammer welcome page:

![image](https://user-images.githubusercontent.com/300/70487560-9b456400-1aaa-11ea-8dd1-d74fa4123154.png)

It's not pretty, but it's a start! Open the page in your editor, change some text and save. Your browser should reload with your new text. Open up `/web/src/Routes.js` and take a look at the route that was created:

    <Route path="/" page={HomePage} name="home" />

Try changing the route to something like:

    <Route path="/hello" page={HomePage} name="home" />

When the browser reloads, you'll see the `NotFoundPage` page. As soon as you add your first route, you'll never see the Hammer splash screen again. From now on, when no route can be found that matches the requested URL, Hammer will render the `NotFoundPage`. Change your URL to `http://localhost:8910/hello" and you should see our page again.

Change the route path back to `/` before continuing!

## A Second Page and a Link

Let's create an "About" page for our blog so everyone knows about the geniuses behind this achievement. We'll create another page using `hammer`:

    hammer generate page about

> Notice that we didn't specify a route path this time. If you leave it off the `hammer generate page` command, Hammer will create a `Route` and give it a path that is the same as the page name you specified prepended with a slash. In this case it will be `/about`.

http://localhost:8910/about should show our new page. But no one's going to find it by manually changing the URL so let's add a link from our homepage to the About page and vice versa. We'll start creating a simple header and nav bar at the same time:

```javascript
// web/src/pages/HomePage/HomePage.js

import { Link, routes } from 'src/lib/HammerRouter'

const HomePage = () => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      Home
    </main>
  )
}

export default HomePage
```

Let's point out a few things here:

- Hammer loves [Function Components](https://www.robinwieruch.de/react-function-component). We'll make extensive use of [React Hooks](https://reactjs.org/docs/hooks-intro.html) as we go and these are only enabled in function components. You're free to use class components, but we recommend avoiding them unless you need their special capabilities.
- Hammer's `<Link>` tag, in its most basic usage, takes a single `to` attribute. That `to` attribute calls a _named route function_ in order to generate the correct URL. The function has the same name as the `name` attribute on the `<Route>`:

    `<Route path="/about" page={AboutPage} name="about" />`

  If you don't like the name that `hammer generate` used for your route, feel free to change it in `Routes.js`! Named routes are awesome because if you ever change the path associated with a route, you need only change it in `Routes.js` and every link using a named route function will still point to the correct place. You can also pass a string to the `to` attribute, but you'll lose out on all the Hammer goodness that named routes provide.

Once we get to the About page we don't have any way to get back so let's add a link there as well:

```javascript
// web/src/pages/AboutPage/AboutPage.js

import { Link, routes } from 'src/lib/HammerRouter'

const AboutPage = () => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      <p>
        This site was created to demonstrate my mastery of Hammer:
        Look on my works, ye mighty, and despair!
      </p>
      <Link to={routes.home()}>Return home</Link>
    </main>
  )
}

export default AboutPage
```

Great! Try that out in the browser and verify you can get back and forth.

As a world-class developer you probably saw that copy and pasted `<header>` and developed an involuntary facial tick. We feel you. That's why Hammer has a little something called _Layouts_.

## Layouts

One way to solve the `<header>` dilemma would be to create a `<Header>` component and include it in both `HomePage` and `AboutPage`. That works, but is there a better solution? Ideally there should only be one reference to the `<header>` anywhere in our code.

When you look at these two pages what do they really care about? They have some content they want to display. They really shouldn't have to care what comes "before" (a `<header>`) or "after" (a `<footer>`). That's exactly what layouts do: they wrap your pages in a component that then renders the page as its child:

<img src="https://user-images.githubusercontent.com/300/70486228-dc874500-1aa5-11ea-81d2-eab69eb96ec0.png" alt="Layouts structure diagram" style="width: 300px">

Let's create a component to hold that `<header>`:

    hammer generate layout blog

That created `/web/src/layouts/BlogLayout/BlogLayout.js`. We're calling this the "blog" layout because we may have other layouts at some point in the future (an "admin" layout, perhaps?).

Cut the `<header>` from both `HomePage` and `AboutPage` and add it to the layout instead. Let's take out the duplicated `<main>` tag as well:

```javascript
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from 'src/lib/HammerRouter'

const BlogLayout = (props) => {
  return (
    <header>
      <h1>Hammer Blog</h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      { props.children }
    </main>
  )
}

export default BlogLayout
```

`props.children` is where the magic will happen. Any page content given to the layout will be rendered here. Back to `HomePage` and `AboutPage`, we add a `<BlogLayout>` wrapper and now they're back to focusing on the content they care about:

```javascript
// web/src/pages/HomePage/HomePage.js
import BlogLayout from 'src/layouts/BlogLayout'

const HomePage = () => {
  return <BlogLayout>Home</BlogLayout>
}

export default HomePage;

// web/src/pages/AboutPage/AboutPage.js
import { Link, routes } from 'src/lib/HammerRouter'
import BlogLayout from 'src/layouts/BlogLayout'

const AboutPage = () => {
  return (
    <BlogLayout>
      <p>
        This site was created to demonstrate my mastery of Hammer:
        Look on my works, ye mighty, and despair!
      </p>
      <Link to={routes.home()}>Return home</Link>
    </BlogLayout>
  )
}

export default AboutPage
```

Back to the browser and you should see...nothing different. But that's good, it means our layout is working.

> ### Why are things named the way they are?
>
> You may have noticed some duplication in Hammer's file names. Pages live in a directory called `/pages` and also contain `Page` in their name. Same with Layouts. What's the deal?
>
> When you have dozens of files open in your editor it's easy to get lost, especially when you have several files with names that are similar or even the same (they happen to be in different directories). We've found that the extra duplication in the names of files is worth the productivity benefit when scanning through your open tabs.
>
> If you're using the [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en) plugin this also helps disambiguate when browsing through your component stack:
>
> <img src="https://user-images.githubusercontent.com/300/70564528-3854db00-1b45-11ea-9976-d6e5ddfb571f.png" style="width:400px">

One more `<Link>`, let's have the title/logo link back to the homepage as per usual:

```javascript
// web/src/layouts/BlogLayout/BlogLayout.js

import { Link, routes } from 'src/lib/HammerRouter'

const BlogLayout = (props) => {
  return (
    <header>
      <h1><Link to={routes.home()}>Hammer Blog</Link></h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      { props.children }
    </main>
  )
}

export default BlogLayout
```

## Getting Dynamic

These two pages are great and all but where are the actual blog posts in this blog? Let's work on those next.

For the purposes of our tutorial we're going to get our blog posts from a database. Because relational databases are still the workhorses of many complex (and not-so-complex) web applications, we've made SQL access a first-class citizen. For Hammer apps, it all starts with the schema.

### Creating the Database Schema

We need to decide what data we'll need for a blog post. We'll expand on this at some point, but at a minimum we'll want to start with:

- `id` the unique identifier for this blog post (all of our database tables will have one of these)
- `title`
- `body` the actual content of the blog post

We use [Prisma Photon](https://photonjs.prisma.io/) to talk to the database. Prisma has another library called Lift that lets us update the database's schema in a predictable way and snapshot each of those changes. Each change is called a _migration_ and Lift will create one when we make changes to our schema.

First let's define the data structure for a post in the database. Open up `/api/prisma/schema.prisma` and add the following:

```javascript
model Post {
  id    Int @id
  title String
  body  String
}
```

### Migrations

That was simple. Now we'll want to snapshot this as a migration:

    hammer db:save

When it asks what you want to name this migration its for your own benefit—neither Hammer nor Photon care about the migration's name. Something like "create posts" is perfect. After the command completes you'll see a new subdirectory under `/api/prisma/migrations` that has a timestamp and the name you gave the migration. It will contain a couple files inside (a snapshot of what the schema looked like at that point in time in `schema.prisma` and the directives that Lift will use make the change to the database in `steps.json`).

We apply the migration with another command:

    hammer db:up

Since this is the first time this command has been run you'll be asked if you want to create the database (yes, you do). It will create a SQLite file at `/api/prisma/dev.db` and then apply the migration, creating a new table called `Post` with the fields we defined above.

### Scaffolding a Post Editor

We haven't decided on the look and feel of our site yet, but wouldn't it be amazing if we could play around with posts without having to build a bunch of pages that we'll probably throw away once the design team gets back to us? Lucky for us, "Amazing" is Hammer's middle name! It has no last name.

Let's generate a _scaffold_ that will allow us to perform all the CRUD actions on posts so we can not only verify that we've got the right fields in the database, but let us get some sample posts in there so we can start laying out our pages and see real content. Hammer has a generator for just the occasion:

    hammer generate scaffold post

Let's point the browser to `http://localhost:8910/posts` and see what we have:

[screenshot]

Well that's barely more than we got when we generated a page. What happens if we click that "New Post" button?

[screenshot]

Okay, now we're getting somewhere. Fill in the title and body and click "Submit".

[screenshot]

Did we just create a post in the database? And then show that post here on this page? Yes, yes we did. Try creating another:

[screenshot]

But what if we click "Edit" on one of those posts?

[Screenshot]

Okay but what if we click "Delete"?

[screenshot]

So, Hammer just created a complete scaffold for our posts table to allow us to perform all CRUD actions through these simple pages. No need to open a GUI or login through a terminal window and write SQL froms scratch. Pretty neat, right?

Here's what happened when we ran that `hammer generate scaffold post` command:

- Added an `sdl.js` file to define several GraphQL queries and mutations in `/api/src/graphql/posts.sdl.js`
- Added a _services_ file in `/api/src/services/posts.js` that makes the Photon calls to get data in and out of the database
- Created several pages in `/web/src/pages`:
  - `PostsPage`
  - `CreatePostPage`
  - `EditPostPage`
  - `ShowPostPage`
- Created routes for those pages in `/web/src/Routes.js`

Since we scaffolded "post" we got the pluralized name for our newly generated SDL, service, and pages (they do deal with multiple posts, not just one post!)

### Creating a Homepage

We can start replacing these pages one by one as we get designs, or maybe move them to the admin section of our site and build our own display pages from scratch. The public facing site won't let viewers create, edit or delete posts. What _can_ they do?

1. View a list of posts (without links to edit/delete)
2. View a single post

Since we'll probably want a way to create and edit posts going forward let's keep the scaffolded pages as they are and create new ones for these two items.

We already have `HomePage` so we won't need to create that. We want to display a list of posts to the user so we'll need to add that logic. We need to get the content from the database and we don't want the user to just see a blank screen in the meantime (depending on network conditions, server location, etc), so we'll want to show some kind of loading message or animation. And if there's an error retrieving the data we should handle that as well. And what about when we open source this blog engine and someone puts it live without any content in the database? It'd be nice if there was some kind of blank slate message.

Oh boy, our first page with data and we already have to worry about loading states, errors, and blank slates...or do we?

### Cells

These features are common in most web apps. We wanted to see if there was something we could do to make developers' lives easier when it comes to adding them to a typical component. We think we've come up with something to help. We call them _Cells_. Cells provide a simpler and more declarative approach to data fetching.

When you create a cell you export several specially named constants and then Hammer takes it from there. A typical cell may look something like:

```javascript
import Post from 'src/components/Post'

export const QUERY = gql`
  query {
    posts {
      id
      title
      body
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>No posts yet!</div>

export const Failure = ({ message }) => <div>Error loading posts: {message}</div>

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article>
      <h2>{ post.title }</h2>
      <div>{ post.body }</div>
    </article>
  ))
}
```

When React renders this component Hammer will:

- Perform the `QUERY` and display the `Loader` component until a response is received
- Once the query returns it will display one of three states:
  - If there was an error, the `Failure` component
  - If the data return is empty (null or empty array), the `Empty` component
  - Otherwise, the `Success` component

There are also some lifecycle helpers like `beforeQuery` (for massaging any props before being given to the `Query`) and `afterQuery` (for massaging the data returned from GraphQL but before being sent to the `Success` component)

The minimum you need for a cell are the `QUERY` and `Success` exports. If you don't export an `Empty` component, empty results will be sent to your `Success` component. Hammer provides default `Loading` and `Failure` components, but you'll most likely want to provide your own custom displays.

A guideline for when to use cells is if your component needs some data from the database or other service that may be delayed in responding. Let Hammer worry about juggling what is displayed when and you can focus on the happy path of the final, rendered component populated with data.

### Our First Cell

The homepage displaying a list of posts is a perfect candidate for our first cell. Naturally, there is a Hammer generator for them:

    hammer generate cell posts

This command will result in a new file at `/web/src/components/PostsCell/PostsCell.js` with some boilerplate to get you started:

```javascript
// web/src/components/PostsCell/PostsCell.js

export const QUERY = gql`
  query {
    posts {
      id
    }
  }
`

export const Loading = () => <div>Loading...</div>

export const Empty = () => <div>Empty</div>

export const Failure = ({ message }) => <div>Error: {message}</div>

export const Success = ({ posts }) => {
  return posts.toString()
}
```

To get you off and running as quickly as possible the generator assumes you've got a root GraphQL query named the same thing as your cell and gives you the minimum query needed to get something out of the database. Let's plug this into our `HomePage` and see what happens:

```javascript
// web/src/pages/HomePage/HomePage.js

import { Link, routes } from 'src/lib/HammerRouter'
import BlogLayout from 'src/layouts/BlogLayout'
import PostsCell from 'src/components/PostsCell'

const HomePage = () => {
  return (
    <BlogLayout>
      <PostsCell />
    </BlogLayout>
  )
}

export default HomePage
```

Reloading the browser should actually show an array with a number or two (assuming you created a blog post with our [scaffolding](#Scaffolding-a-Post-Editor) from earlier). Neat!

> **In the `Success` component, where did `posts` come from?**
>
> Notice in the `QUERY` that the query we're making is `posts`. Whatever the name of this query is, that's the name of the prop that will be available in `Success` with your data. You can alias the name of the variable containing the result of the GraphQL query, and that will be the name of the prop:

```javascript
export const QUERY = gql`
  query {
    postIds: posts {
      id
    }
  }
`
```

> Now `postIds` will be available in `Success` instead of `posts`

In addition to the `id` that was added to the `query` by the generator, let's get the title and body, too:

```javascript
// web/src/components/PostsCell/PostsCell.js

export const QUERY = gql`
  query {
    posts {
      id
      title
      body
    }
  }
`
```

Reload the page and you should see a dump of all the data you created for any blog posts you scaffolded.

Now we're in the realm of good ol' React components, so just build out the `Success` component to display the blog post in a nicer format:

```javascript
// web/src/components/PostsCell/PostsCell.js

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article>
      <header>
        <h2>{post.title}</h2>
      </header>
      <div>{post.body}</h2>
    </article>
  ))
}
```

And just like that we have a blog! It may be the most basic, ugly blog that ever graced the internet, but it's something! (Don't worry, we've got more features to add.)

[screenshot]

To sum up, what did we actually do to get this far?

1. Generate the homepage
2. Generate the blog layout
3. Define the database schema
4. Run migrations to update the database and create a table
5. Scaffold a CRUD interface to the database table
6. Create a cell to load the data and take care of loading/empty/failure/success states
7. Add the cell to the page

This will become a standard lifecycle of new features as you build a Hammer app.

So far, other than a little HTML, we haven't had to do much by hand. And we especially didn't have to write a bunch of plumbing just to move data from one place to another. Makes web development a little more enjoyable, don't you think?

## Side Quest: How Hammer Works with Data

(Investigation into how the GraphQL SDL files map to services, auto-generation of resolvers, etc)

## Displaying a Single Blog Post - Routing Params

Now that we have our homepage listing all the posts, let's build the "detail" page—a canonical URL that displays a single post. First we'll generate the page and route:

    hammer generate page post

Now let's link the title of the post on the homepage to the detail page:

```javascript
// web/src/components/PostsCell/PostsCell.js

export const Success = ({ posts }) => {
  return posts.map((post) => (
    <article>
      <header>
        <h2>
          <Link to={routes.post()}>{post.title}</Link>
        </h2>
      </header>
      <div>{post.body}</h2>
    </article>
  ))
}
```

If you reload and click the link you should see the boilerplate text on `PostPage`. But what we really need is to specify _which_ post we want to view on this page. It would be nice to be able to specify the ID of the post in the URL with something like `/post/1`. Let's tell the `<Route>` to expect another part of the URL, and when it does, give that part a name that we can reference later:

```javascript
// web/src/Routes.js

<Route path="/post/:id" page={PostPage} name="post" />
```

Notice the `:id`. Hammer calls these _route parameters_. They say "whatever value is in this position in the path, call it _this_ (without the colon) and let me reference it later."

Cool, cool, cool. But now we need to construct a link that has the ID of a post in it. Hammer time!

```javascript
// web/src/pages/PostsPage/PostsPage.js

<Link to={routes.post({ id: post.id })}>{post.title}</Link>
```

For routes with route parameters, the named route function expects an object where you specify a value for each parameter. If you click on the link now, it will indeed take you to `/post/1` (or `/post/2`, etc, depending on the ID of the post).

Ok, so the ID is in the URL. What do we need next in order to display a specific post? It sounds like we'll be doing some data retrieval from the database, which means we want a cell:

    hammer generate cell post

And then we'll use that cell in `PostPage` (and while we're at it let's surround the page with the `BlogLayout`):

```javascript
// web/src/pages/PostPage/PostPage.js

import { Link, routes } from 'src/lib/HammerRouter'
import BlogLayout from 'src/layouts/BlogLayout'
import PostCell from 'src/components/PostCell'

const PostPage = () => {
  return (
    <BlogLayout>
      <PostCell />
    </BlogLayout>
  )
}

export default PostPage
```

Now over to the cell, we need access to that `:id` route param so we can look up the ID of the post in the database. Let's update the query to accept a variable:

```javascript
// web/src/cells/PostCell/PostCell.js

export const Query = gql`
  query($id: Int) {
    post(id: $id) {
      id
      title
      body
    }
  }
```

And update `Success` to dump the contents of the `post` query so we can see if it worked:

```javascript
// web/src/cells/PostCell/PostCell.js

export const Success = ({ post }) => {
  return post.toString()
}
```

Okay, we're getting closer. Still, where will that `$id` come from? Hammer has another trick up its sleeve. Whenever you put a route param in a route, that param is automatically made available to the page that route renders. Which means we can update `PostPage` to look like this:

```javascript
// web/src/pages/PostPage/PostPage.js

const PostPage = ({ id }) => {
  return (
    <BlogLayout>
      <PostCell id={id} />
    </BlogLayout>
  )
}
```

`id` already exists since we named our route param `:id`. Thanks Hammer! But how does that `id` end up as the `$id` GraphQL parameter? If you've learned anything about Hammer by now, you should know it's going to take care of that for you! By default, any props you give to a cell will automatically be turned into variables and given to the query. "Say what!" you're saying. It's true!

I'll prove it! Just reload the browser and—uh oh. Hmm. Okay that's not our fault. This little bug is brought to us by the original HTTP spec: everything in the URL is considered a string, but GraphQL wants an integer for the ID. So in this case we'll need to convert it before it's turned into a variable for GraphQL. Luckily we've got a nice place to do that: as it's passed into the cell:

```javascript
// web/src/pages/PostPage/PostPage.js

const PostPage = () => {
  return (
    <BlogLayout>
      <PostCell id={parseInt(id)} />
    </BlogLayout>
  )
}
```

Voilá!

> **What if I want to pass some other prop to the cell that I don't need in the query, but do need in the Success/Loader/etc. components?**
>
> All of the props you give to the cell will be automatically available as props in the render components. Only the ones that match the GraphQL variables list will be given to the query. You get the best of both worlds! In our post display above, if you wanted to display some random number along with the post (for some contrived, tutorial-like reason), just pass that prop:

```javascript
<PostCell id={id} rand={Math.random()}>
```

> And get it, along with the query result (and even the original `id` if you want) in the component:

```javascript
export const Success = ({ post, id, rand }) => {
  //...
}
```

> Thanks again, Hammer!

Now let's display the actual post instead of just dumping the query result. This seems like the perfect place for a good old fashioned component since we're displaying a post on both the home page and this detail page, and it's (currently) the same exact output. Let's Hammer-up a component (I just invented that phrase):

    hammer generate component post

Which creates `web/src/components/Post/Post.js` as a super simple React component:

```javascript
// web/src/components/Post/Post.js

const Post = () => {
  return null
}

export default Post
```

> You may notice we don't have any explict `import` statements for `React` itself. We (the Hammer dev team) got tired of constantly importing it over and over again in every file so we automatically import it for you!

Let's take the post display code out of `PostsCell` and put it here instead, taking the `post` in as a prop:

```javascript
// web/src/components/Post/Post.js

const Post = ({ post }) => {
  return (
    <article>
      <header>
        <h2>
          <Link to={routes.post({ id: post.id })}>{post.title}</Link>
        </h2>
      </header>
      <div>{post.body}</h2>
    </article>
  )
}

export default Post
```

And update `PostsCell` and `PostCell` to use this new component instead:

```javascript
// web/src/components/PostsCell/PostsCell.js
export const Success = ({ posts }) => {
  return posts.map((post) => <Post post={post}>)
}

// web/src/components/PostCell/PostCell.js
export const Success = ({ post }) => {
  return <Post post={post}>
}
```

And there we go! We should be able to move back and forth between the homepage and the detail page.

Let's summarize:

1. We created a new page to show a single post (the "detail" page)
2. We added a route to handle the `id` of the post and turn it into a route param
3. We created a cell to fetch and display the post
4. Hammer made the world a better place by making that `id` available to us at several key junctions in our code
5. We turned the actual post display into a standard React component and used it in both the homepage and new detail page.

## Side Quest: Naming Conventions

- Why things are named like Component/Component.js
- Storybook and tests
- SDL and services

## Everyone's Favorite Thing to Build: Forms

Wait, don't close your browser! You had to know this was coming eventually, didn't you? And you've probably realized by now we wouldn't even have this section in the tutorial unless Hammer had figured out a way to make forms less soul-sucking than usual. In fact Hammer might even make you _love_ building forms. Well, love is a strong word. _Like_ building forms. _Tolerate_ building them?

We already have a form or two in our app; remember our posts scaffold? And those work pretty well! How hard can it be? (Hopefully you haven't sneaked a peek at that code—what's coming next will be much more impressive if you haven't yet.)

Let's build the simplest form that still makes sense for our blog, a "contact us" form.

### The Page

    hammer generate page contact

We can put a link to Contact in our header:

```javascript
// web/src/layouts/BlogLayout/BlogLayout.js

const BlogLayout = (props) => {
  return (
    <header>
      <h1><Link to={routes.home()}>Hammer Blog</Link></h1>
      <nav>
        <ul>
          <li><Link to={routes.about()}>About</Link></li>
          <li><Link to={routes.contact()}>Contact</Link></li>
        </ul>
      </nav>
    </header>
    <main>
      { props.children }
    </main>
  )
}
```

Double check that everything looks good and then let's get to the good stuff.

### Introducing HammerForm

Forms in React are infamously annoying to work with. There are [Controlled Components](https://reactjs.org/docs/forms.html#controlled-components) and [Uncontrolled Components](https://reactjs.org/docs/uncontrolled-components.html) and [third party libraries](https://jaredpalmer.com/formik/) and many more workarounds to try and make forms in React as simple as they were originally intended to be: an `<input>` field with a `name` attribute that gets submitted somewhere when you click a `<button>`.

We think Hammer is a step or two in the right direction by not only freeing you from writing controlled component plumbing, but also dealing with validation and errors automatically. Let's see how it works.

For now we won't be talking to the database in our Contact form so we won't create a cell. Let's create the form right on the page. Hammer forms start with the...wait for it...`<HammerForm>` tag:

```javascript
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = (props) => {
  return <HammerForm></HammerForm>;
}

export default ContactPage
```

Well that was anticlimactic. You can't even see it in the browser. Let's add a form field so we can at least see something. Hammer ships with several inputs and a plain text input box is `<TextField>`. We'll also give the field a `name` attribute so that once there are multiple inputs on this page we'll know which contains which data:

```javascript
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = (props) => {
  return (
    <HammerForm>
      <TextField name="input" />
    </HammerForm>
  )
}
```

[screenshot]

Something it showing! Still, pretty boring. How about adding a submit button?

```javascript
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = (props) => {
  return (
    <HammerForm>
      <TextField name="input" />
      <Submit>Save</Submit>
    </HammerForm>
  )
}
```

[screenshot]

We have what might actually be considered a real, bonafide form here. Try typing something in and clicking "Save". Nothing blew up but we have no indication that the form submitted or what happened to the data. Next we'll get the data in our fields.

### onSubmit

Similar to a plain HTML form we'll give `<HammerForm>` an `onSubmit` handler. That handler will be called with a single argument—an object containing all of the submitted form fields:

```javascript
// web/src/pages/ContactPage/ContactPage.js

const ContactPage = (props) => {
  const onSubmit = (data) {
    console.log(data)
  }

  return (
    <HammerForm onSubmit={onSubmit}>
      <TextField name="input" />
      <Submit>Save</Submit>
    </HammerForm>
  )
}
```

Now try filling in some data and submitting:

[screenshot]

Great! Let's turn this into a more useful form by adding a couple fields. We'll rename the existing one to "name" and add "email" and "message":

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <TextField name="name" />
    <TextField name="email" />
    <TextArea name="message" />
    <Submit>Save</Submit>
  </HammerForm>
)
```

See the new `<TextArea>` component here which generates an HTML `<textarea>` but that contains Hammer's form goodness. If we reload now our fields are there but there's no indication of which is which and everything is kind of jumbled together:

[screenshot]

Let's add some labels and just a tiny bit of styling to at least separate the fields onto their own lines.

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name" style={{ display: 'block' }} />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email" style={{ display: 'block' }}/>

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message" style={{ display: 'block' }} />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

[screenshot]

That's a little better. Try filling out the form and submitting and you should get a console message with all three fields now.

### Validation

"Okay Hammer tutorial author," you're saying, "what's the big deal? You built up Hammer's form helpers as The Next Big Thing but there are plenty of libraries that will let me skip creating controlled inputs manually. So what?" And you're right! But anyone can fill out a form *correctly* (although there are plenty of QA folks who would challenge that assumption), what happens when someone leaves something out, or makes a mistake, or tries to haxorz our form? Now who's going to be there to help? Hammer, that's who!

All three of these fields should be required in order for someone to send a message to us. Let's enforce that with the standard HTML `required` attribute:

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name" style={{ display: 'block' }} required />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email" style={{ display: 'block' }} required />

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message" style={{ display: 'block' }} required />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

Now when trying to submit there'll be message from the browser noting that a field must be filled in. This is better than nothing, but these messages can't be styled. Can we do better?

Yes! Let's update that `required` call to instead be an object we pass to a custom attribute on Hammer form helpers called `validation`:

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name" style={{ display: 'block' }} validation={{ required: true }} />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email" style={{ display: 'block' }} validation={{ required: true }} />

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message" style={{ display: 'block' }} validation={{ required: true }} />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

And now when we submit the form with blank fields...nothing happens. That seems worse, not better. But this is just a stepping stone to our amazing reveal! We have one more form helper component to add—the one that displays errors on a field. Oh it just so happens that it's plain HTML so we can style it however we want! Introducing `<FieldError>`:

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name" style={{ display: 'block' }} validation={{ required: true }} />
    <FieldError name="name" />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email" style={{ display: 'block '}} validation={{ required: true }} />
    <FieldError name="email" />

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message" style={{ display: 'block' }} validation={{ required: true }} />
    <FieldError name="message" />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

Note that the `name` attribute matches the `name` of the input field above it. That's so it knows which field to display errors for. Try submitting that form now.

[screenshot]

But this is just the beginning. Let's make sure folks realize this is an error message:

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name" style={{ display: 'block' }} validation={{ required: true }} />
    <FieldError name="name" style={{ color: 'red' }} />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email" style={{ display: 'block' }} validation={{ required: true }} />
    <FieldError name="email" style={{ color: 'red' }} />

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message" style={{ display: 'block' }} validation={{ required: true }} />
    <FieldError name="message" style={{ color: 'red' }} />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

[screenshot]

You know what would be nice, if the input itself somehow displayed the fact that there was an error:

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <label for="name" style={{ display: 'block' }}>Name</label>
    <TextField name="name"
               style={{ display: 'block' }}
               errorStyle={{ borderColor: 'red' }}
               validation={{ required: true }} />
    <FieldError name="name" style={{ color: 'red' }} />

    <label for="email" style={{ display: 'block' }}>Email</label>
    <TextField name="email"
               style={{ display: 'block' }}
               errorStyle={{ borderColor: 'red' }}
               validation={{ required: true }} />
    <FieldError name="email" style={{ color: 'red' }} />

    <label for="message" style={{ display: 'block' }}>Message</label>
    <TextArea name="message"
              style={{ display: 'block' }}
              errorStyle={{ borderColor: 'red' }}
              validation={{ required: true }} />
    <FieldError name="message" style={{ color: 'red' }} />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

Oooo, what if the *label* could change as well? It can, but we'll need Hammer's custom `<Label>` component for that (note that `for` becomes `name` just like the other components):

```javascript
// web/src/pages/ContactPage/ContactPage.js

return (
  <HammerForm onSubmit={onSubmit}>
    <Label name="name"
           style={{ display: 'block' }}
           errorStyle={{ color: 'red' }}>Name</Label>
    <TextField name="name"
               style={{ display: 'block' }}
               errorStyle={{ borderColor: 'red' }}
               validation={{ required: true }} />
    <FieldError name="name" style={{ color: 'red' }} />

    <Label name="name"
           style={{ display: 'block' }}
           errorStyle={{ color: 'red' }}>Email</Label>
    <TextField name="email"
               style={{ display: 'block' }}
               errorStyle={{ borderColor: 'red' }}
               validation={{ required: true }} />
    <FieldError name="email" style={{ color: 'red' }} />

    <Label name="name"
           style={{ display: 'block' }}
           errorStyle={{ color: 'red' }}>Message</Label>
    <TextArea name="message"
              style={{ display: 'block' }}
              errorStyle={{ borderColor: 'red' }}
              validation={{ required: true }} />
    <FieldError name="message" style={{ color: 'red' }} />

    <Submit style={{ display: 'block' }}>Save</Submit>
  </HammerForm>
)
```

[screenshot]

> In addition to `style` and `errorStyle` you can also use `className` and `errorClassName`

We should make sure the email field actually contains an email:

```javascript
// web/src/pages/ContactPage/ContactPage.js

<TextField name="email"
           style={{ display: 'block' }}
           errorStyle={{ borderColor: 'red' }}
           validation={{
             required: true,
             pattern: {
               value: /[^@]+@[^\.]+\..+/
             }
           }} />
```

That is definitely not the end-all-be-all for email address validation, but pretend it's bulletproof. Let's also change the message on the email validation to be a little more friendly:

```javascript
// web/src/pages/ContactPage/ContactPage.js

<TextField name="email"
           style={{ display: 'block' }}
           errorStyle={{ borderColor: 'red' }}
           validation={{
             required: true,
             pattern: {
               value: /[^@]+@[^\.]+\..+/,
               message: 'Please enter a valid email address'
             }
           }} />
```

You probably noticed that trying to submit a form with validation errors should output nothing to the console—it's not actually submitting. Fix the errors and all is well.

Finally, you know what would *really* be nice: if the fields were validated as soon as the user leaves each one so they don't fill out the whole thing and submit just to see multiple errors appear. Let's do that:

```javascript
// web/src/pages/ContactPage/ContactPage.js

<HammerForm onSubmit={onSubmit} validation={{ mode: 'onBlur' }}>
```

Well, what do you think? Was it worth the hype? I couple new components and you've got forms that handle validation and wrap up submitted values in a nice data object, all for free.

> Hammer's forms are built on top of [React Hook Form](https://react-hook-form.com/) so there is even more functionality available than we've documented here.

Hammer has one more trick up its sleeve when it comes to forms but we'll save that for when we're actually submitting one to the server.

Having a contact form is great, but only if you actually get the contact somehow. Let's create a database table to hold the submitted data and create our first GraphQL mutation.

## Saving Data

- Create migration
- lift up
- Generate SDL
- Create service
- Simulate server error (remove validation on client form field so server blows up)

## Administration

- Move original post scaffold to /admin
- Authentication to lock down access
- First deploy so that we can setup Netlify identity

## Deployment

- Branch deploys
- Netlify forms
- Custom functions
